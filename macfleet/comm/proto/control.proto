// MacFleet Control Plane Protocol
// gRPC service definitions for cluster coordination

syntax = "proto3";

package macfleet;

// Main cluster control service
service ClusterControl {
    // Node registration with the coordinator
    rpc Register(RegisterRequest) returns (RegisterResponse);

    // Periodic heartbeat from workers
    rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);

    // Synchronization barrier for distributed training
    rpc SyncBarrier(BarrierRequest) returns (BarrierResponse);

    // Start distributed training
    rpc StartTraining(TrainingConfigProto) returns (Ack);

    // Stop distributed training
    rpc StopTraining(StopRequest) returns (Ack);

    // Get current cluster state
    rpc GetClusterState(Empty) returns (ClusterStateProto);

    // Broadcast message to all nodes
    rpc Broadcast(BroadcastRequest) returns (Ack);
}

// Empty message for requests with no parameters
message Empty {}

// Generic acknowledgment
message Ack {
    bool success = 1;
    string message = 2;
}

// Node registration request from worker to coordinator
message RegisterRequest {
    string hostname = 1;
    string ip_address = 2;
    int32 gpu_cores = 3;
    int32 ram_gb = 4;
    float memory_bandwidth_gbps = 5;
    int32 tensor_port = 6;
}

// Registration response from coordinator
message RegisterResponse {
    int32 assigned_rank = 1;
    float workload_weight = 2;
    int32 world_size = 3;
    string master_tensor_addr = 4;
    int32 master_tensor_port = 5;
}

// Heartbeat request from worker
message HeartbeatRequest {
    int32 rank = 1;
    float throughput_samples_per_sec = 2;
    string thermal_state = 3;  // "nominal", "fair", "serious", "critical"
    int64 timestamp_ms = 4;
    int32 current_step = 5;
}

// Heartbeat response from coordinator
message HeartbeatResponse {
    bool acknowledged = 1;
    float new_workload_weight = 2;  // Updated weight if rebalancing occurred
    bool should_stop = 3;  // Signal to stop training
}

// Synchronization barrier request
message BarrierRequest {
    int32 rank = 1;
    int32 step = 2;
    string barrier_id = 3;
}

// Barrier response
message BarrierResponse {
    bool proceed = 1;
    int32 nodes_at_barrier = 2;
}

// Training configuration for distributed training
message TrainingConfigProto {
    int32 epochs = 1;
    int32 batch_size = 2;
    float learning_rate = 3;
    string compression = 4;  // "none", "topk", "fp16", "topk_fp16"
    float topk_ratio = 5;
    int32 checkpoint_every = 6;
    string checkpoint_dir = 7;
    string device = 8;
}

// Request to stop training
message StopRequest {
    string reason = 1;
    bool save_checkpoint = 2;
}

// Node information in cluster state
message NodeInfoProto {
    int32 rank = 1;
    string hostname = 2;
    string ip_address = 3;
    int32 gpu_cores = 4;
    int32 ram_gb = 5;
    float memory_bandwidth_gbps = 6;
    int32 tensor_port = 7;
    float workload_weight = 8;
    string status = 9;  // "connected", "disconnected", "training"
    float last_throughput = 10;
    string thermal_state = 11;
    int64 last_heartbeat_ms = 12;
}

// Full cluster state
message ClusterStateProto {
    int32 world_size = 1;
    repeated NodeInfoProto nodes = 2;
    bool training_active = 3;
    int32 current_epoch = 4;
    int32 current_step = 5;
    string training_status = 6;  // "idle", "training", "paused", "completed"
}

// Broadcast request for sending messages to all nodes
message BroadcastRequest {
    string message_type = 1;  // "weights", "config", "command"
    bytes payload = 2;
    int32 source_rank = 3;
}
